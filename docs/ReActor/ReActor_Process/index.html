<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ReActor_Process (ReActor.ReActor_Process)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="..">Up</a> â€“ <a href="../">ReActor</a> &#x00BB; ReActor_Process</nav><h1>Module <code>ReActor_Process</code></h1></header><article class="spec module" id="module-Message"><a href="#module-Message" class="anchor"></a><code><span class="keyword">module </span><a href="Message">Message</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module" id="module-Pid"><a href="#module-Pid" class="anchor"></a><code><span class="keyword">module </span><a href="Pid">Pid</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module" id="module-Status"><a href="#module-Status" class="anchor"></a><code><span class="keyword">module </span><a href="Status">Status</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><dl><dt class="spec type" id="type-behavior"><a href="#type-behavior" class="anchor"></a><code><span class="keyword">type </span>'s behavior</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-behavior.Terminate" class="anchored"><td class="def constructor"><a href="#type-behavior.Terminate" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Terminate</span></code></td><td class="doc"><p>Indicate that this actor should not become a new actor but instead should be terminated as soon as the current computation completes.</p></td></tr><tr id="type-behavior.Become" class="anchored"><td class="def constructor"><a href="#type-behavior.Become" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Become</span><span class="keyword"> of </span><span class="type-var">'s</span></code></td><td class="doc"><p>Indicate that this actor should become a new actor with the same identifier and mailbox, but with a new state <code>'s</code>.</p></td></tr><tr id="type-behavior.Suspend" class="anchored"><td class="def constructor"><a href="#type-behavior.Suspend" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Suspend</span><span class="keyword"> of </span>int<span class="keyword"> * </span><span class="type-var">'s</span></code></td><td class="doc"><p>Indicate this actor should become a new actor with new state <code>'s</code> in <i>at most</i> <code>n</code> milliseconds.</p></td></tr><tr id="type-behavior.OnAnimationFrame" class="anchored"><td class="def constructor"><a href="#type-behavior.OnAnimationFrame" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">OnAnimationFrame</span><span class="keyword"> of </span><span class="type-var">'s</span></code></td><td class="doc"><p>Indicate that this actor should <a href="#type-behavior.Become"><code>Become</code></a> as soon as the next Animation Frame is available; this is particularly useful for rendering purposes.</p></td></tr></table><code></code></dt><dd><p>The Behavior type defines how a given Actor will behave as soon as the current computation is completed.</p><p>It is in fact a value of this type that the computation <i>must</i> return.</p><p>The literature tends to uses the name <a href="#type-behavior.Become"><code>Become</code></a> to indicate that an actor will <i>somehow</i> turn into a new actor, with the exact same identifier and mailbox, but that will begin it's execution with a different set of inputs.</p><p>In essence, if an actor's main function looks like:</p><pre><code class="ml">let proc: Process.f(int) = (_, counter) =&gt; Become(counter + 1)</code></pre><p>Then this actor will increment it's internal counter by 1 on every scheduled execution, and it will continue doing so for as long as the system is running.</p><p>A slightly different actor:</p><pre><code class="ml">let proc: Process.f(int) = (_, counter) =&gt; Suspend(counter, counter+1)</code></pre><p>Will be indefinitely scheduled (like the one above) and wait <code>counter</code> milliseconds before becoming a new actor with an incremented counter.</p></dd></dl><dl><dt class="spec type" id="type-env"><a href="#type-env" class="anchor"></a><code><span class="keyword">type </span>'s env</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-env.self" class="anchored"><td class="def field"><a href="#type-env.self" class="anchor"></a><code>self : unit <span>&#45;&gt;</span> <a href="Pid#type-t">Pid.t</a>;</code></td></tr><tr id="type-env.recv" class="anchored"><td class="def field"><a href="#type-env.recv" class="anchor"></a><code>recv : unit <span>&#45;&gt;</span> <a href="Message#type-t">Message.t</a> option;</code></td></tr></table><code>}</code><code></code></dt><dd><p>The environment type.</p><p>Each <code>process</code> gets access to an environment <code>env</code> that gives them the capability to</p><ul><li>use <code>self</code> to access it's own <code>Pid.t</code> (useful for establishing communications).</li><li>Use <code>recv</code> to consume messages from their mailbox.</li></ul><p>The semantics of <code>recv</code> dictate that if the mailbox is **empty**, the process will await for a message to arrive before continuing.</p></dd></dl><dl><dt class="spec type" id="type-f"><a href="#type-f" class="anchor"></a><code><span class="keyword">type </span>'s f</code><code><span class="keyword"> = </span><span class="type-var">'s</span> <a href="#type-env">env</a> <span>&#45;&gt;</span> <span class="type-var">'s</span> <span>&#45;&gt;</span> <span class="type-var">'s</span> <a href="#type-behavior">behavior</a></code><code></code></dt><dd><p>The type of a <code>process</code> function. It receives an environment and a given state.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-t.pid" class="anchored"><td class="def field"><a href="#type-t.pid" class="anchor"></a><code>pid : <a href="Pid#type-t">Pid.t</a>;</code></td><td class="doc"><p>The identifier for this process.</p></td></tr><tr id="type-t.status" class="anchored"><td class="def field"><a href="#type-t.status" class="anchor"></a><code>status : <a href="Status#type-t">Status.t</a> Pervasives.ref;</code></td><td class="doc"><p>Whether this process is currently Alive or if it has been naturally or abruptly Terminated.</p></td></tr><tr id="type-t.mailbox" class="anchored"><td class="def field"><a href="#type-t.mailbox" class="anchor"></a><code>mailbox : <a href="Message#type-t">Message.t</a> list Pervasives.ref;</code></td><td class="doc"><p>The list of messages associated to this <a href="Pid#type-t"><code>Pid.t</code></a>.</p></td></tr></table><code>}</code><code></code></dt><dd><p>The Process type.</p><p>A process consists of a <code>mailbox</code>, where the messages will be stored; a <code>pid</code> that identifies it uniquely among all the other processes in the system; and a <code>status</code> that indicates whether the process will continue executing or if it will stop executing after the current scheduled computation ends.</p></dd></dl><dl><dt class="spec value" id="val-markAsDead"><a href="#val-markAsDead" class="anchor"></a><code><span class="keyword">val </span>markAsDead : <a href="#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-keepAlive"><a href="#val-keepAlive" class="anchor"></a><code><span class="keyword">val </span>keepAlive : <a href="#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-send"><a href="#val-send" class="anchor"></a><code><span class="keyword">val </span>send : <a href="Message#type-t">Message.t</a> <span>&#45;&gt;</span> <a href="#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-recv"><a href="#val-recv" class="anchor"></a><code><span class="keyword">val </span>recv : <a href="#type-t">t</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="Message#type-t">Message.t</a> option</code></dt><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val </span>make : <a href="Pid#type-t">Pid.t</a> <span>&#45;&gt;</span> <span class="type-var">'s</span> <a href="#type-f">f</a> <span>&#45;&gt;</span> <span class="type-var">'s</span> <span>&#45;&gt;</span> <a href="#type-t">t</a></code></dt><dd><p>Create a brand new process and begin executing it's main function.</p><p>Given a <code>pid</code> and a function <code>f</code>, a new <code>process</code> will be created with an empty <code>mailbox</code>; alongside it, an environment <code>env</code> will be created that will have access to the <code>pid</code> and the processes' <code>mailbox</code>.</p><p>A process is never recreated when using <code>loop</code>, <code>recv</code>, or <code>sleep</code>, and it will continue to maintain it's identify (<code>pid</code>) until it is marked as <code>Dead</code>.</p><p>The <code>process</code> begins executing immediately before this function returns the <code>process</code> descriptor.</p></dd></dl></div></body></html>