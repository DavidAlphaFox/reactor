<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (ReActor.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="..">Up</a> â€“ <a href="../">ReActor</a> &#x00BB; index</nav></header><h1 id="top"><a href="#top" class="anchor"></a>ðŸš€ re:actor â€” Bringing Typesafe Message-passing Concurrency to the Web</h1><p><code>re:actor</code> is an <em>experimental</em> type-safe, message-passing concurrency library. It is not meant for production and has no stable API.</p><p>For the top-level library module see <a href="ReActor"><code>ReActor</code></a>.</p>
<nav class="toc">
<ol><li><a href="#introduction">Introduction</a></li><li><p><a href="#overview">Overview</a></p><ol><li><a href="#2.1-basics">Basics</a></li><li><a href="#2.2-processes-and-behaviors">Processes and Behaviors</a></li><li><a href="#2.3-guaranteed-message-passing">Guaranteed Message-passing</a></li><li><a href="#2.4-typesafe-message-passing">Typesafe Message-passing</a></li><li><a href="#2.5-seamless-multi-core">Seamless Multi-core</a></li><li><a href="#2.6-fair-scheduling">Fair Scheduling</a></li></ol></li><li><p><a href="#experiments">Experiments</a></p><ol><li><a href="#3.1-simple-spawning">Simple Spawning</a></li><li><a href="#3.2-simple-message-passing">Simple Message Passing</a></li><li><a href="#3.3-collaborating-processes">Collaborating Processes</a></li><li><a href="#3.4-more-collaborating-processes">More Collaborating Processes</a></li><li><a href="#3.5-processes-for-the-dom">Processes for the DOM</a></li><li><a href="#3.6-processes-with-react">Processes with React</a></li><li><a href="#3.7-tracing-messages">Tracing Messages</a></li><li><a href="#3.8-processes-orchestrating-processes">Processes Orchestrating Processes</a></li></ol></li><li><a href="#benchmarks">Benchmarks</a></li><li><a href="#conclusion">Conclusion</a></li><li><a href="#references">References</a></li></ol>
</nav>
<h2 id="introduction"><a href="#introduction" class="anchor"></a>1. Introduction</h2><p>Web applications today run by default in a single-threaded event loop that does not effectively leverage the many-core architectures available. This means that in a many-core computer, where a web application could be potentially executing many parallel actions at once, it typically executes only one.</p><p>The appearance of Web Workers changed this by allowing arbitrary Javascript code to be executed in a separate event-loop that can communicate with the main event loop via message passing and transferable data structures. To this day it still is not trivial to leverage them: given they are very coarse low-level features, any higher-level concurrency feature is left to be implemented at the application level.</p><p>To aggravate this issue, a failure or resource-starvation in the main program of a worker will effectively take the worker out of service.</p><p>To address these issues, <code>re:actor</code> began as an experiment for type-safe, message-passing concurrent computation modeled after Smalltalk-72, Erlang, and Gul Agha's Actor model.</p><p>This experiment will be evaluated based on how well it provides:</p><ul><li>Multi-core Support: or how seamlessly it allows an application to leverage parallelism in many-core computers.</li></ul><ul><li>Failure Isolation: a process failure should not have an implicit impact on the rest of the system.</li></ul><ul><li>Type-safe Message Passing: processes can be checked handle all of the messages they expect to handle at compile time.</li></ul><p>By writing a number of small projects that showcase these capabilities.</p><h2 id="overview"><a href="#overview" class="anchor"></a>2. Overview</h2><p><code>re:actor</code> is designed to allow web applications to be expressed as a group of independent processes that communicate by sending messages to each other, and can run leveraging the entire of their host machines available computing power seamlessly.</p>
<img
  title="re:actor powered architecture"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/reactor/docs/assets/high-level-sketch.png"
/>
<h3 id="2.1-basics"><a href="#2.1-basics" class="anchor"></a>2.1 Basics</h3><p>Let us start by introducing the basic constructs the library builds upon.</p><p><b>Processes</b> applications built with <code>re:actor</code> consist of running processes. These processes model <i>tasks</i> that have to be carried out and <i>entities</i> that evolve over time, in the form of <i>functions</i> with associated identities and mailboxes. These processes can be as simple as incrementing a counter, or as complex as coordinating transactions across other processes. They collaborate by <i>message-passing</i>. In practice, processes can blend completely into the domain of the application, making them an incredibly versatile abstraction to model systems with.</p><p><b>Messages</b> Messages are typed data structures that processes send to each other to communicate.</p><p><b>Schedulers</b> All processes must be scheduled for execution, and to do this there exist schedulers. Processes and their mailboxes live within particular schedulers. A scheduler corresponds to a single event-loop, and this could be either the Main Thread of a browser, or a Web Worker. Every time a process send a message, it is a scheduler that will make sure it gets delivered.</p><p><b>Nodes</b> All schedulers within a running system have to be orchestrated by a node. Nodes typically map 1-to-1 with a single computer. If you're running a <code>re:actor</code> application in a single browser, you'd normally run a single node. A node will make sure there are as many schedulers as machine cores available and that they are healthy at all points. 
<img
  title="Overall constructs"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/reactor/docs/assets/constructs-sketch.png"
/>
</p><h3 id="2.2-processes-and-behaviors"><a href="#2.2-processes-and-behaviors" class="anchor"></a>2.2 Processes and Behaviors</h3><p>A Process is in essence a function with an associated identity and a mailbox.</p><pre><code class="ml">type process = ( func, pid, mailbox );</code></pre><p>Every process has a unique identifier, it's <i>pid</i>, that can be used to locate the process and send messages to it's mailbox from anywhere in the node.</p><p>The function that defines the process is a function from a particular initial state to a behavior change. There is a limited number of behaviors that encode termination of a process' execution, continuation, and suspension. Additionally, a particular mode of suspension catered for performing drawing on the Web is included: suspension until the next animation frame.</p><pre><code class="ml">type behavior('s) =
  | Become('s)
  | OnAnimationFrame('s)
  | Suspend(int, 's)
  | Terminate;</code></pre><p>Every process definition function will take an initial state and return one of the above behaviors, making it possible to re-schedule itself by <i>becoming</i> a process with the same identity, the same definition function, and a new initial state.</p><h3 id="2.3-guaranteed-message-passing"><a href="#2.3-guaranteed-message-passing" class="anchor"></a>2.3 Guaranteed Message-passing</h3><p>Processes communicate with other processes via <i>message passing</i>, where a message gets copied from the sending process to the receiving process' mailbox.</p><p>Message passing in <code>re:actor</code> is <i>guaranteed to deliver messages</i>. However, because the behavior of a process consists of application code that might never consume messages from it's mailbox, it is impossible to guarantee that messages will be consumed.</p>
<img
  title="Message-passing"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/reactor/docs/assets/message-passing-sketch.png"
/>
<p>To guarantee message passing, the <code>send</code> function available to all processes within a node is <i>synchronous</i> and will fail if the message could not be effectively copied to the receiving mailbox.</p><h3 id="2.4-typesafe-message-passing"><a href="#2.4-typesafe-message-passing" class="anchor"></a>2.4 Typesafe Message-passing</h3><p>To provide further safety, a process must define exactly what messages to accept when consuming it's mailbox, and should only be able to handle such messages.</p><p>This particular capability is powered by the type-system underneath Reason.</p><h3 id="2.5-seamless-multi-core"><a href="#2.5-seamless-multi-core" class="anchor"></a>2.5 Seamless Multi-core</h3><p>By making processes <i>relocatable</i>, they can be started in any of the available schedulers.</p><h3 id="2.6-fair-scheduling"><a href="#2.6-fair-scheduling" class="anchor"></a>2.6 Fair Scheduling</h3><p>Languages like Erlang or Smalltalk have mechanisms for principledly preemptive scheduling, in which the execution of a particular process will be suspended, allowing other processes to be executed without any loss of state.</p><p>However, the Web platform and in particular Javascript, have no such mechanisms.</p><p>In Javascript, any function that includes an infinite loop will yield a process that never terminates, and any function making use of recursion may cause a stack-overflow that will crash a process.</p><p>Because of this impediments, the scheduling of <code>re:actor</code> is designed to entrust to the user the responsibility of building processes out of <i>total functions</i> that terminate in <i>negligible amounts of time</i>. Naturally, this isn't always possible, and when it isn't, the tradeoffs have to be made clear.</p><p>If a process' function definition is <i>partial</i> or executes a time-intense computation, it will block the scheduler until it terminates.</p><h2 id="experiments"><a href="#experiments" class="anchor"></a>3. Experiments</h2><p>The experiments below (up to number 7th) started off as <i>Koans</i> for the library. They serve as good examples of how to use the library, increasing in complexity, and to describe additional features that were found necessary to build web applications.</p><h3 id="3.1-simple-spawning"><a href="#3.1-simple-spawning" class="anchor"></a>3.1 Simple Spawning</h3><p><a href="https://github.com/ostera/reactor/blob/master/examples/koans/E1_SimpleSpawning.re">View Source</a> â€” <a href="/reactor/examples/koans/E1_SimpleSpawning.re.html">Run experiment (make sure to have the console open)</a>.</p><p>Let us begin with a simple process: a monotonically incremental counter.</p><pre><code class="ml">/**
  Sample state that includes a simple integer counter.
  */
type sample = {n: int};

/**
  A counter process that will increment it's counter by one on each evaluation.
  */
let counter: Process.f(sample) = (_env, state) =&gt; Become({n: state.n + 1});</code></pre><p>This process definition is amongst the simplest possible ones. It defines a process that will simply become itself with a new initial state, where the counter value <code>n</code> is incremented by 1 in every step.</p>
<img
  title="Process becoming a new process with new state"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/reactor/docs/assets/process-becoming.png"
/>
<p>How fast will this particular counter increment itself? As fast as it gets scheduled for execution.</p><p>We can schedule this process for execution like this:</p><pre><code class="ml">let counter_pid: Pid.t = spawn(counter, {n: 0});</code></pre><p>But this isn't very useful, since we can't make use of that internal value without recurring to mutable shared state with <code>refs</code>. We avoid communicating by sharing memory and instead we share memory by communicating.</p><p>Let's instead add another process definition that will show us this data in some form so we verify it is indeed working:</p><pre><code class="ml">/**
  A counter process that will increment it's counter by one on each evaluation
  and will log out a message when the counter reaches a certain number.
  */
let printing_counter: int =&gt; Process.f(sample) = (number, _env, state) =&gt; {
  if (state.n == number) {
    Js.log({j|Reached number $number|j});
  };
  Become({n: state.n + 1});
};</code></pre><p>Now spawning one process with behavior <code>printing_counter(2112)</code> will eventually print out <i>&quot;Reached number 2112&quot;</i>. A small problem appears when we have multiple processes running in this way:</p><pre><code class="ml">let p1 = spawn(printing_counter(2112), {n: 0});
let p2 = spawn(printing_counter(2112), {n: 0});
let p3 = spawn(printing_counter(2112), {n: 0});

/* eventually... */
&lt; Reached number 2112
&lt; Reached number 2112
&lt; Reached number 2112</code></pre><p>What printing belongs to which process? We can find out information about the current process by accessing the <i>process environment</i>: <a href="ReActor_Process#type-env"><code>ReActor_Process.env</code></a>. It is available as the <code>_env</code> parameter that we see in both definitions above. We can use the function <a href="ReActor_Process#type-env.self"><code>ReActor_Process.env.self</code></a> to get the current process identifier, and refactor to print it out:</p><pre><code class="ml">let printing_counter: int =&gt; Process.f(sample) = (number, env, state) =&gt; {
  if (state.n == number) {
    let pid = env.self() |&gt; Pid.toString;
    Js.log({j|$pid :: Reached number $number|j});
  };
  Become({n: state.n + 1});
};</code></pre><p>And now running it prints out the identifier of the process on each line:</p><pre><code class="ml">&lt;0,0,1&gt; :: Reached number 2112
&lt;0,0,3&gt; :: Reached number 2112
&lt;0,0,2&gt; :: Reached number 2112</code></pre>
<img
  title="Process becoming a new process with same identifier"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/reactor/docs/assets/process-becoming-with-identity.png"
/>
<h3 id="3.2-simple-message-passing"><a href="#3.2-simple-message-passing" class="anchor"></a>3.2 Simple Message Passing</h3><p><a href="https://github.com/ostera/reactor/blob/master/examples/koans/E2_SimpleMessagePassing.re">View Source</a> â€” <a href="/reactor/examples/koans/E2_SimpleMessagePassing.re.html">Run experiment (make sure to have the console open)</a>.</p><h3 id="3.3-collaborating-processes"><a href="#3.3-collaborating-processes" class="anchor"></a>3.3 Collaborating Processes</h3><p><a href="https://github.com/ostera/reactor/blob/master/examples/koans/E3_CollaboratingProcesses.re">View Source</a> â€” <a href="/reactor/examples/koans/E3_CollaboratingProcesses.re.html">Run experiment (make sure to have the console open)</a>.</p><h3 id="3.4-more-collaborating-processes"><a href="#3.4-more-collaborating-processes" class="anchor"></a>3.4 More Collaborating Processes</h3><p><a href="https://github.com/ostera/reactor/blob/master/examples/koans/E4_MoreCollaboratingProcesses.re">View Source</a> â€” <a href="/reactor/examples/koans/E4_MoreCollaboratingProcesses.re.html">Run experiment (make sure to have the console open)</a>.</p><h3 id="3.5-processes-for-the-dom"><a href="#3.5-processes-for-the-dom" class="anchor"></a>3.5 Processes for the DOM</h3><p><a href="https://github.com/ostera/reactor/blob/master/examples/koans/E5_ProcessesForTheDOM.re">View Source</a> â€” <a href="/reactor/examples/koans/E5_ProcessesForTheDOM.re.html">Run experiment (make sure to have the console open)</a>.</p><h3 id="3.6-processes-with-react"><a href="#3.6-processes-with-react" class="anchor"></a>3.6 Processes with React</h3><p><a href="https://github.com/ostera/reactor/blob/master/examples/koans/E6_ProcessesWithReact.re">View Source</a> â€” <a href="/reactor/examples/koans/E6_ProcessesWithReact.re.html">Run experiment (make sure to have the console open)</a>.</p><h3 id="3.7-tracing-messages"><a href="#3.7-tracing-messages" class="anchor"></a>3.7 Tracing Messages</h3><p><a href="https://github.com/ostera/reactor/blob/master/examples/koans/E7_TracingMessages.re">View Source</a> â€” <a href="/reactor/examples/koans/E7_TracingMessages.re.html">Run experiment (make sure to have the console open)</a>.</p><h3 id="3.8-processes-orchestrating-processes"><a href="#3.8-processes-orchestrating-processes" class="anchor"></a>3.8 Processes Orchestrating Processes</h3><p><a href="https://github.com/ostera/reactor/blob/master/examples/koans/E8_ProcesssesOrchestratingProcesses.re">View Source</a> â€” <a href="/reactor/examples/koans/E8_ProcesssesOrchestratingProcesses.re.html">Run experiment (make sure to have the console open)</a>.</p><h2 id="conclusion"><a href="#conclusion" class="anchor"></a>4. Benchmarks</h2><h2 id="conclusion"><a href="#conclusion" class="anchor"></a>5. Conclusion</h2><h2 id="references"><a href="#references" class="anchor"></a>6. References</h2><ul><li><a href="https://en.wikipedia.org/wiki/Smalltalk">Smalltalk</a></li><li><a href="http://www.erlang.org/">Erlang</a> and <a href="https://elixir-lang.org/">Elixir</a></li><li><a href="https://arxiv.org/vc/arxiv/papers/1008/1008.1459v8.pdf">Hewitt's Actor Model of Computation</a></li><li><a href="https://mitpress.mit.edu/books/actors">Gul Agha's Actors</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">Web Workers</a></li><li><a href="http://www-inst.eecs.berkeley.edu/~n252/paper/Amdahl.pdf">Amdahl's Law</a></li></ul></div></body></html>