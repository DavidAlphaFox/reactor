<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (ReActor.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="..">Up</a> â€“ <a href="../">ReActor</a> &#x00BB; index</nav></header><h1 id="top"><a href="#top" class="anchor"></a>ðŸš€ re:actor</h1><p><code>re:actor</code> is an <em>experimental</em> type-safe, message-passing concurrency library. It is not meant for production and has no stable API.</p>
<nav class="toc">
<ol><li><a href="#introduction">Introduction</a></li><li><p><a href="#overview">Overview</a></p><ol><li><a href="#2.1-basics">Basics</a></li><li><a href="#2.2-processes-and-behaviors">Processes and Behaviors</a></li><li><a href="#2.3-guaranteed-message-passing">Guaranteed Message-passing</a></li><li><a href="#2.4-typesafe-message-passing">Typesafe Message-passing</a></li><li><a href="#2.5-seamless-multi-core">Seamless Multi-core</a></li><li><a href="#2.6-fair-scheduling">Fair Scheduling</a></li></ol></li><li><a href="#conclusion">Conclusion</a></li><li><a href="#references">References</a></li></ol>
</nav>
<h2 id="introduction"><a href="#introduction" class="anchor"></a>1. Introduction</h2><p>Web applications today run by default in a single-threaded event loop that does not effectively leverage the many-core architectures available. This means that in a many-core computer, where a web application could be potentially executing many parallel actions at once, it typically executes only one.</p><p>The appearance of Web Workers changed this by allowing arbitrary Javascript code to be executed in a separate event-loop that can communicate with the main event loop via message passing and transferrable data structures. To this day it still is not trivial to leverage them: given they are very coarse low-level features, any higher-level concurrency feature is left to be implemented at the application level.</p><p>To aggravate this issue, a failure or resource-starvation in the main program of a worker will effectively take the worker out of service.</p><p>To address these issues, <code>re:actor</code> began as an experiment for type-safe, message-passing concurrent computation modeled after Smalltalk-72, Erlang, and Gul Agha's Actor model.</p><p>This experiment will be evaluated based on how well it provides:</p><ul><li>Multi-core Support: or how seamlessly it allows an application to leverage parallelism in many-core computers.</li></ul><ul><li>Failure Isolation: a process failure should not have an implicit impact on the rest of the system.</li></ul><ul><li>Type-safe Message Passing: processes can be checked handle all of the messages they expect to handle at compile time.</li></ul><p>By writing a number of small projects that showcase these capabilities.</p><h2 id="overview"><a href="#overview" class="anchor"></a>2. Overview</h2><p><code>re:actor</code> is designed to allow web applications to be expressed as a group of independent processes that communicate by sending messages to each other, and can run leveraging the entire of their host machines available computing power seamlessly.</p>
<img
  title="re:actor powered architecture"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/reactor/assets/high-level-sketch.png"
/>
<h3 id="2.1-basics"><a href="#2.1-basics" class="anchor"></a>2.1 Basics</h3><p>Let us start by introducing the basic constructs the library builds upon.</p><p><b>Processes</b> applications built with <code>re:actor</code> consist of running processes. These processes model <i>tasks</i> that have to be carried out and <i>entities</i> that evolve over time, in the form of <i>functions</i> with associated identities and mailboxes. These processes can be as simple as incrementing a counter, or as complex as coordinating transactions across other processes. They collaborate by <i>message-passing</i>. In practice, processes can blend completely into the domain of the application, making them an incredibly versatile abstraction to model systems with.</p><p><b>Messages</b> Messages are typed data structures that processes send to each other to communicate.</p><p><b>Schedulers</b> All processes must be scheduled for execution, and to do this there exist schedulers. Processes and their mailboxes live within particular schedulers. A scheduler corresponds to a single event-loop, and this could be either the Main Thread of a browser, or a Web Worker. Every time a process send a message, it is a scheduler that will make sure it gets delivered.</p><p><b>Nodes</b> All schedulers within a running system have to be orchestrated by a node. Nodes typically map 1-to-1 with a single computer. If you're running a <code>re:actor</code> application in a single browser, you'd normally run a single node. A node will make sure there are as many schedulers as machine cores available and that they are healthy at all points. 
<img
  title="Overall constructs"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/reactor/assets/constructs-sketch.png"
/>
</p><h3 id="2.2-processes-and-behaviors"><a href="#2.2-processes-and-behaviors" class="anchor"></a>2.2 Processes and Behaviors</h3><p>A Process is in essence a function with an associated identity and a mailbox.</p><pre><code class="ml">type process = ( func, pid, mailbox );</code></pre><p>Every process has a unique identifier, it's <i>pid</i>, that can be used to locate the process and send messages to it's mailbox from anywhere in the node.</p><p>The function that defines the process is a function from a particular initial state to a behavior change. There is a limited number of behaviors that encode termination of a process' execution, continuation, and suspension. Additionally, a particular mode of suspension catered for performing drawing on the Web is included: suspension until the next animation frame.</p><pre><code class="ml">type behavior('s) =
  | Become('s)
  | OnAnimationFrame('s)
  | Suspend(int, 's)
  | Terminate;</code></pre><p>Every process definition function will take an initial state and return one of the above behaviors, making it possible to re-schedule itself by <i>becoming</i> a process with the same identity, the same definition function, and a new initial state.</p><h3 id="2.3-guaranteed-message-passing"><a href="#2.3-guaranteed-message-passing" class="anchor"></a>2.3 Guaranteed Message-passing</h3><p>Processes communicate with other processes via <i>message passing</i>, where a message gets copied from the sending process to the receiving process' mailbox.</p><p>Message passing in <code>re:actor</code> is <i>guaranteed to deliver messages</i>. However, because the behavior of a process consists of application code that might never consume messages from it's mailbox, it is impossible to guarantee that messages will be consumed.</p>
<img
  title="Message-passing"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/reactor/assets/message-passing-sketch.png"
/>
<h3 id="2.4-typesafe-message-passing"><a href="#2.4-typesafe-message-passing" class="anchor"></a>2.4 Typesafe Message-passing</h3><p>To provide further safety, a process must define exactly what messages to accept when consuming it's mailbox, and should only be able to handle such messages.</p><p>This particular capability is powered by the type-system underneath Reason.</p><h3 id="2.5-seamless-multi-core"><a href="#2.5-seamless-multi-core" class="anchor"></a>2.5 Seamless Multi-core</h3><p>By making processes <i>relocatable</i>, they can be started in any of the available schedulers.</p><h3 id="2.6-fair-scheduling"><a href="#2.6-fair-scheduling" class="anchor"></a>2.6 Fair Scheduling</h3><p>Languages like Erlang or Smalltalk have mechanisms for principledly preemptive scheduling, in which the execution of a particular process will be suspended, allowing other processes to be executed without any loss of state.</p><p>However, the Web platform and in particular Javascript, have no such mechanisms.</p><p>In Javascript, any function that includes an infinite loop will yield a process that never terminates, and any function making use of recursion may cause a stack-overflow that will crash a process.</p><p>Because of this impediments, the scheduling of <code>re:actor</code> is designed to entrust to the user the responsibility of building processes out of <i>total functions</i> that terminate in <i>negligible amounts of time</i>. Naturally, this isn't always possible, and when it isn't, the tradeoffs have to be made clear.</p><p>If a process' function definition is <i>partial</i> or executes a time-intense computation, it will block the scheduler until it terminates.</p><h2 id="conclusion"><a href="#conclusion" class="anchor"></a>4. Conclusion</h2><h2 id="references"><a href="#references" class="anchor"></a>5. References</h2><ul><li><a href="https://en.wikipedia.org/wiki/Smalltalk">Smalltalk</a></li><li><a href="http://www.erlang.org/">Erlang</a> and <a href="https://elixir-lang.org/">Elixir</a></li><li><a href="https://arxiv.org/vc/arxiv/papers/1008/1008.1459v8.pdf">Hewitt's Actor Model of Computation</a></li><li><a href="https://mitpress.mit.edu/books/actors">Gul Agha's Actors</a></li><li><a href="https://developer.mozilla.org/en-US/reactor/Web/API/Web_Workers_API">Web Workers</a></li><li><a href="http://www-inst.eecs.berkeley.edu/~n252/paper/Amdahl.pdf">Amdahl's Law</a></li></ul></div></body></html>