<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (ReActor.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="..">Up</a> â€“ <a href="../">ReActor</a> &#x00BB; index</nav></header><h1 id="top"><a href="#top" class="anchor"></a>ðŸš€ re:actor</h1><p><code>re:actor</code> is an <em>experimental</em> type-safe, message-passing concurrency library. It is not meant for production and has no stable API.</p><ol><li><a href="#introduction">Introduction</a></li><li><a href="#design">Design</a></li><li><a href="#conclusion">Conclusion</a></li><li><a href="#references">References</a></li></ol><h2 id="introduction"><a href="#introduction" class="anchor"></a>1. Introduction</h2><p>Web applications today run in a single-threaded event loop that does not effectively leverage the many-core architectures available. This means that in a many-core computer, where a web application could be potentially executing many parallel actions at once, it typically executes only one.</p><p>The appearance of Web Workers changed this by allowing arbitrary code to be executed in a separate event-loop that can communicate with the main event loop via message passing and transferrable data structures. To this day it still is not trivial to leverage them, given they are very coarse low-level features and capabilities such as message handling, serializing data structures, and coordinating program execution are left for the applications themselves.</p><p>To address these issues, <code>re:actor</code> began as an experiment for type-safe, message-passing concurrent computation modeled after Smalltalk-72, Erlang, and Gul Agha's Actor model.</p><p>I will attempt to evaluate this experiment on how well it provides:</p><ul><li>Symmetric Multiprocessing: or how seamlessly it allows an application to leverage parallelism in multi-core computers.</li><li>Failure Isolation: a process failure should not have an implicit impact on the rest of the system.</li><li>Type-safe Message Passing: process failure due to unexpected messages should be detected at compile time.</li></ul><h2 id="design"><a href="#design" class="anchor"></a>2. Design</h2><p><code>re:actor</code> is designed to allow web applications to be expressed as a group of independent processes that communicate by sending messages to each other, and can run leveraging the entire of their host machines available computing power.</p>
<img
  title="re:actor powered architecture"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/docs/assets/high-level-sketch.png"
/>
<h3 id="core-abstractions"><a href="#core-abstractions" class="anchor"></a>Core Abstractions</h3><p>To help you build scalable applications, the library includes a small set of constructs at different levels of abstraction:</p><ul><li>Nodes and Schedulers at the Platform-level, and</li><li>Processes and Mesages at the Application-level.</li></ul><h5 id="platform-level"><a href="#platform-level" class="anchor"></a>Platform-level</h5><p><i>Nodes</i> are responsible for orchestrating schedulers, and they typically map 1-to-1 with a single computer. If you're running a re:actor application in a single browser, on a single computer, you'd normally run a single node. A node will make sure there are as many schedulers as machine cores available and that they are healthy at all points. They also have run-time information about the system they are running on.</p><p><i>Schedulers</i> are the ones that run processes and deliver messages. Each scheduler corresponds to a single event-loop, and this could be either the Main Thread of a browser, or a Web Worker. Every time a process send a message, it is a scheduler that will make sure it gets delivered.</p>
<img
  title="Overall constructs"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/docs/assets/constructs-sketch.png"
/>
<h5 id="application-level"><a href="#application-level" class="anchor"></a>Application-level</h5><p><i>Processes</i> are what applications are made of. They represent <i>tasks</i> that have to be carried out. In the literature they are also referred to as:</p><ul><li><i>Objects</i> in Smalltalk,</li><li><i>Actors</i> in the Actor-model, or</li><li><i>Processes</i> in Erlang.</li></ul><p>They can be short lived or long lived, one-offs or self-scheduling, they can be static or change their state over time. These tasks can be as simple as incrementing an internal counter and logging out any message that is received, or as complex as coordinating transactions across other processes. They are an incredibly powerful abstraction to work with.</p><p><code>re:actor</code> applications can consist of hundreds of thousands or even millions of processes.</p><p>Processes communicate with other processes via <i>message passing</i>, where a message gets copied from the sending process to the receiving process' mailbox.</p><p><i>Messages</i> are data structures that processes send to each other to communicate.</p><p>Message passing in <code>re:actor</code> is <i>guaranteed to deliver messages</i>. However, because the behavior of a process consists of application code that might never consume messages from it's mailbox, it is impossible to guarantee that messages will be consumed.</p>
<img
  title="Message-passing"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/docs/assets/message-passing-sketch.png"
/>
<h2 id="conclusion"><a href="#conclusion" class="anchor"></a>3. Conclusion</h2><p>While the core abstractions can be implemented in the web platform with certain shortcomings, the overall idea</p><h2 id="references"><a href="#references" class="anchor"></a>4. References</h2><ul><li><a href="https://en.wikipedia.org/wiki/Smalltalk">Smalltalk</a></li><li><a href="http://www.erlang.org/">Erlang</a> and <a href="https://elixir-lang.org/">Elixir</a></li><li><a href="https://arxiv.org/vc/arxiv/papers/1008/1008.1459v8.pdf">Hewitt's Actor Model of Computation</a></li><li><a href="https://mitpress.mit.edu/books/actors">Gul Agha's Actors</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">Web Workers</a></li><li><a href="http://www-inst.eecs.berkeley.edu/~n252/paper/Amdahl.pdf">Amdahl's Law</a></li></ul></div></body></html>