// Generated by BUCKLESCRIPT VERSION 4.0.5, PLEASE EDIT WITH CARE

import * as List from "../../../../node_modules/bs-platform/lib/es6/list.js";
import * as Block from "../../../../node_modules/bs-platform/lib/es6/block.js";
import * as Curry from "../../../../node_modules/bs-platform/lib/es6/curry.js";
import * as Option from "./Option.bs.js";
import * as ReActor from "../../src/ReActor.bs.js";
import * as Game_FFI from "./Game_FFI.bs.js";
import * as Game_Timer from "./Game_Timer.bs.js";
import * as Caml_exceptions from "../../../../node_modules/bs-platform/lib/es6/caml_exceptions.js";

var name = "renderer";

var Pipeline = Caml_exceptions.create("Game_Renderer.Pipeline");

var Flush = Caml_exceptions.create("Game_Renderer.Flush");

var Paint = Caml_exceptions.create("Game_Renderer.Paint");

function paint(state, param) {
  switch (param.tag | 0) {
    case 0 : 
        Game_FFI.Canvas[/* fillRect */3](state[/* buffer_ctx */2], /* Rect */[
              0,
              0,
              Game_FFI.Viewport[/* width */0](/* () */0),
              Game_FFI.Viewport[/* height */1](/* () */0)
            ], /* Hex */Block.__(0, [3556687]));
        return /* () */0;
    case 1 : 
        Game_FFI.Canvas[/* fillText */4](state[/* buffer_ctx */2], param[0], param[1], param[2]);
        return /* () */0;
    case 2 : 
        Game_FFI.Canvas[/* fillRect */3](state[/* buffer_ctx */2], param[0], param[1]);
        return /* () */0;
    
  }
}

function handleMessage(state, message) {
  if (message[0] === Paint) {
    Game_FFI.Canvas[/* fillRect */3](state[/* buffer_ctx */2], message[1], message[2]);
    return /* Become */Block.__(0, [state]);
  } else if (message === Flush) {
    var match = state[/* status */0];
    if (match) {
      Game_FFI.Canvas[/* fillRect */3](state[/* screen */3], /* Rect */[
            0,
            0,
            Game_FFI.Viewport[/* width */0](/* () */0),
            Game_FFI.Viewport[/* height */1](/* () */0)
          ], /* Hex */Block.__(0, [3556687]));
      Game_FFI.Canvas[/* drawImage */5](state[/* buffer */1], state[/* screen */3], /* Point2D */[
            0,
            0
          ]);
      return /* Become */Block.__(0, [/* record */[
                  /* status : Flushed */0,
                  /* buffer */state[/* buffer */1],
                  /* buffer_ctx */state[/* buffer_ctx */2],
                  /* screen */state[/* screen */3]
                ]]);
    } else {
      return /* Become */Block.__(0, [state]);
    }
  } else if (message[0] === Pipeline) {
    List.iter((function (param) {
            return paint(state, param);
          }), message[1]);
    return /* Become */Block.__(0, [/* record */[
                /* status : CanFlush */1,
                /* buffer */state[/* buffer */1],
                /* buffer_ctx */state[/* buffer_ctx */2],
                /* screen */state[/* screen */3]
              ]]);
  } else {
    return /* Become */Block.__(0, [state]);
  }
}

function loop(env, state) {
  return Option.$less$pipe$great(Option.$great$great$pipe(Curry._1(env[/* recv */1], /* () */0), (function (param) {
                    return handleMessage(state, param);
                  })), /* Become */Block.__(0, [state]));
}

function start() {
  var buffer = Game_FFI.Canvas[/* create */0](/* () */0);
  var initialState_002 = /* buffer_ctx */Game_FFI.Canvas[/* get2dContext */1](buffer);
  var initialState_003 = /* screen */Game_FFI.Canvas[/* get2dContext */1](Game_FFI.DOM[/* elementById */3]("game"));
  var initialState = /* record */[
    /* status : CanFlush */1,
    /* buffer */buffer,
    initialState_002,
    initialState_003
  ];
  var pid = ReActor.register(name, ReActor.spawn(loop, initialState));
  Game_Timer.start(/* record */[
        /* target */pid,
        /* message */Flush,
        /* time */16
      ]);
  return pid;
}

export {
  name ,
  Pipeline ,
  Flush ,
  Paint ,
  paint ,
  handleMessage ,
  loop ,
  start ,
  
}
/* ReActor Not a pure module */
