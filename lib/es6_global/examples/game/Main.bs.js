// Generated by BUCKLESCRIPT VERSION 4.0.5, PLEASE EDIT WITH CARE

import * as List from "../../../../node_modules/bs-platform/lib/es6/list.js";
import * as Block from "../../../../node_modules/bs-platform/lib/es6/block.js";
import * as Curry from "../../../../node_modules/bs-platform/lib/es6/curry.js";
import * as Option from "./Option.bs.js";
import * as ReActor from "../../src/ReActor.bs.js";
import * as Game_FFI from "./Game_FFI.bs.js";
import * as EventHandler from "./EventHandler.bs.js";
import * as Caml_exceptions from "../../../../node_modules/bs-platform/lib/es6/caml_exceptions.js";

var name = "renderer";

var Paint = Caml_exceptions.create("Main.Renderer.Paint");

function handleMessage(state, message) {
  if (message[0] === Paint) {
    Game_FFI.Canvas[/* fillRect */2](state[/* canvas */1], message[1], message[2]);
    return /* Become */Block.__(0, [state]);
  } else {
    return /* Become */Block.__(0, [state]);
  }
}

function loop(env, state) {
  return Option.$less$pipe$great(Option.$great$great$pipe(Curry._1(env[/* recv */1], /* () */0), (function (param) {
                    return handleMessage(state, param);
                  })), /* Become */Block.__(0, [state]));
}

function start() {
  var initialState_001 = /* canvas */Game_FFI.Canvas[/* get2dContext */0](Game_FFI.DOM[/* elementById */2]("game"));
  var initialState = /* record */[
    /* fpsCap */30,
    initialState_001
  ];
  return ReActor.register(name, ReActor.spawn(loop, initialState));
}

var Renderer = /* module */[
  /* name */name,
  /* Paint */Paint,
  /* handleMessage */handleMessage,
  /* loop */loop,
  /* start */start
];

var Pointer = /* module */[];

function repaint(surface, color) {
  Option.$great$great$pipe(ReActor.where_is(name), (function (pid) {
          return ReActor.send(pid, [
                      Paint,
                      surface,
                      color
                    ]);
        }));
  return /* () */0;
}

var events = /* :: */[
  /* Click */3,
  /* :: */[
    /* MouseMove */4,
    /* :: */[
      /* KeyDown */1,
      /* :: */[
        /* Resize */2,
        /* [] */0
      ]
    ]
  ]
];

function registerEvents(self) {
  Option.$great$great$pipe(ReActor.where_is(EventHandler.name), (function (pid) {
          return List.iter((function (param) {
                        return ReActor.send(pid, param);
                      }), List.map((function (e) {
                            return [
                                    EventHandler.Subscribe,
                                    e,
                                    self
                                  ];
                          }), events));
        }));
  return /* () */0;
}

function setup(env, state) {
  repaint(state[/* surface */2], state[/* color */1]);
  registerEvents(Curry._1(env[/* self */0], /* () */0));
  return /* Become */Block.__(0, [/* record */[
              /* started */true,
              /* color */state[/* color */1],
              /* surface */state[/* surface */2]
            ]]);
}

function handleEvent(state, param) {
  if (typeof param === "number") {
    return /* Become */Block.__(0, [state]);
  } else {
    switch (param.tag | 0) {
      case 0 : 
          console.log("key down", param[0], param[1]);
          return /* Become */Block.__(0, [state]);
      case 1 : 
          console.log("click at", param[0], param[1]);
          return /* Become */Block.__(0, [state]);
      case 2 : 
          console.log("mouse move at", param[0], param[1]);
          return /* Become */Block.__(0, [state]);
      case 3 : 
          var state$prime_000 = /* started */state[/* started */0];
          var state$prime_001 = /* color */state[/* color */1];
          var state$prime_002 = /* surface : Rect */[
            0,
            0,
            param[0],
            param[1]
          ];
          var state$prime = /* record */[
            state$prime_000,
            state$prime_001,
            state$prime_002
          ];
          repaint(state$prime_002, state$prime_001);
          return /* Become */Block.__(0, [state$prime]);
      
    }
  }
}

function handleMessage$1(state, param) {
  if (param[0] === EventHandler.Event) {
    return handleEvent(state, param[1]);
  } else {
    return /* Become */Block.__(0, [state]);
  }
}

function loop$1(env, state) {
  if (state[/* started */0]) {
    return Option.$less$pipe$great(Option.$great$great$pipe(Curry._1(env[/* recv */1], /* () */0), (function (param) {
                      return handleMessage$1(state, param);
                    })), /* Become */Block.__(0, [state]));
  } else {
    return setup(env, state);
  }
}

function start$1() {
  return ReActor.spawn(loop$1, /* record */[
              /* started */false,
              /* color : Hex */Block.__(0, [3556687]),
              /* surface : Rect */[
                0,
                0,
                Game_FFI.Viewport[/* width */0](/* () */0),
                Game_FFI.Viewport[/* height */1](/* () */0)
              ]
            ]);
}

var Scene = /* module */[
  /* repaint */repaint,
  /* events */events,
  /* registerEvents */registerEvents,
  /* setup */setup,
  /* handleEvent */handleEvent,
  /* handleMessage */handleMessage$1,
  /* loop */loop$1,
  /* start */start$1
];

function start$2() {
  EventHandler.start(/* () */0);
  start(/* () */0);
  start$1(/* () */0);
  return /* () */0;
}

var Game = /* module */[/* start */start$2];

ReActor.trace(/* record */[
      /* matcher */(function (_, _$1) {
          return true;
        }),
      /* handler */(function (prim) {
          console.log(prim);
          return /* () */0;
        }),
      /* timeout */705032704
    ]);

start$2(/* () */0);

export {
  Renderer ,
  Pointer ,
  Scene ,
  Game ,
  
}
/*  Not a pure module */
