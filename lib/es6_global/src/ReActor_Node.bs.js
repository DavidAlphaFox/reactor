// Generated by BUCKLESCRIPT VERSION 4.0.5, PLEASE EDIT WITH CARE

import * as List from "../../../node_modules/bs-platform/lib/es6/list.js";
import * as ReActor_Utils$Reactor from "./ReActor_Utils.bs.js";
import * as Caml_builtin_exceptions from "../../../node_modules/bs-platform/lib/es6/caml_builtin_exceptions.js";
import * as ReActor_Scheduler$Reactor from "./ReActor_Scheduler.bs.js";

function make() {
  var node_name = ReActor_Utils$Reactor.Random[/* shortId */3](/* () */0);
  return /* record */[
          /* node_name */node_name,
          /* schedulers : :: */[
            /* record */[/* contents */ReActor_Scheduler$Reactor.make(node_name)],
            /* [] */0
          ],
          /* registry : record */[/* contents : [] */0]
        ];
}

function spawn(node, f, args) {
  return ReActor_Scheduler$Reactor.spawn(f, args, ReActor_Scheduler$Reactor.leastBusy(node[/* schedulers */1]));
}

function exit(node, pid) {
  return ReActor_Scheduler$Reactor.exit(pid, ReActor_Scheduler$Reactor.findById(ReActor_Scheduler$Reactor.pidToSid(pid))(node[/* schedulers */1]));
}

function register(node, name, pid) {
  node[/* registry */2][0] = /* :: */[
    /* tuple */[
      name,
      pid
    ],
    node[/* registry */2][0]
  ];
  return pid;
}

function where_is(node, name) {
  var byName = function (param) {
    return List.find((function (param) {
                  return name === param[0];
                }), param);
  };
  var exit = 0;
  var val;
  try {
    val = byName(node[/* registry */2][0]);
    exit = 1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return undefined;
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    return val[1];
  }
  
}

function send(node, pid, msg) {
  return ReActor_Scheduler$Reactor.send(pid, msg, ReActor_Scheduler$Reactor.findById(ReActor_Scheduler$Reactor.pidToSid(pid))(node[/* schedulers */1]));
}

export {
  make ,
  spawn ,
  exit ,
  register ,
  where_is ,
  send ,
  
}
/* No side effect */
