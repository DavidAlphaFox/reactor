// Generated by BUCKLESCRIPT VERSION 4.0.5, PLEASE EDIT WITH CARE

import * as List from "../../../node_modules/bs-platform/lib/es6/list.js";
import * as $$Array from "../../../node_modules/bs-platform/lib/es6/array.js";
import * as Caml_array from "../../../node_modules/bs-platform/lib/es6/caml_array.js";
import * as FFI_Runtime from "./FFI_Runtime.bs.js";
import * as ReActor_Utils from "./ReActor_Utils.bs.js";
import * as ReActor_Scheduler from "./ReActor_Scheduler.bs.js";
import * as Caml_builtin_exceptions from "../../../node_modules/bs-platform/lib/es6/caml_builtin_exceptions.js";

function make() {
  var node_name = ReActor_Utils.Random[/* shortId */3](/* () */0);
  return /* record */[
          /* node_name */node_name,
          /* schedulers : :: */[
            /* record */[/* contents */ReActor_Scheduler.make(node_name)],
            List.map((function (prim) {
                    return /* record */[/* contents */prim];
                  }), List.map((function () {
                        return ReActor_Scheduler.make(node_name);
                      }), $$Array.to_list(Caml_array.caml_make_vect(FFI_Runtime.hardwareConcurrency - 1 | 0, 0))))
          ],
          /* registry : record */[/* contents : [] */0]
        ];
}

function trace(node, tracer) {
  return List.iter((function (param) {
                return ReActor_Scheduler.trace(tracer, param);
              }), node[/* schedulers */1]);
}

function spawn(node, f, args) {
  return ReActor_Scheduler.spawn(f, args, ReActor_Scheduler.leastBusy(node[/* schedulers */1]));
}

function exit(node, pid) {
  return ReActor_Scheduler.exit(pid, ReActor_Scheduler.findById(ReActor_Scheduler.pidToSid(pid))(node[/* schedulers */1]));
}

function register(node, name, pid) {
  node[/* registry */2][0] = /* :: */[
    /* tuple */[
      name,
      pid
    ],
    node[/* registry */2][0]
  ];
  return pid;
}

function whereIs(node, name) {
  var byName = function (param) {
    return List.find((function (param) {
                  return name === param[0];
                }), param);
  };
  var exit = 0;
  var val;
  try {
    val = byName(node[/* registry */2][0]);
    exit = 1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return undefined;
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    return val[1];
  }
  
}

function send(node, pid, message) {
  return ReActor_Scheduler.send(pid, message, ReActor_Scheduler.findById(ReActor_Scheduler.pidToSid(pid))(node[/* schedulers */1]));
}

export {
  make ,
  trace ,
  spawn ,
  exit ,
  register ,
  whereIs ,
  send ,
  
}
/* FFI_Runtime Not a pure module */
