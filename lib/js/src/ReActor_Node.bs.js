// Generated by BUCKLESCRIPT VERSION 4.0.5, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var FFI_Runtime = require("./FFI_Runtime.bs.js");
var ReActor_Utils = require("./ReActor_Utils.bs.js");
var ReActor_Scheduler = require("./ReActor_Scheduler.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function make() {
  var node_name = ReActor_Utils.Random[/* shortId */3](/* () */0);
  return /* record */[
          /* node_name */node_name,
          /* schedulers : :: */[
            /* record */[/* contents */ReActor_Scheduler.make(node_name)],
            List.map((function (prim) {
                    return /* record */[/* contents */prim];
                  }), List.map((function () {
                        return ReActor_Scheduler.make(node_name);
                      }), $$Array.to_list(Caml_array.caml_make_vect(FFI_Runtime.hardwareConcurrency - 1 | 0, 0))))
          ],
          /* registry : record */[/* contents : [] */0]
        ];
}

function trace(node, tracer) {
  return List.iter((function (param) {
                return ReActor_Scheduler.trace(tracer, param);
              }), node[/* schedulers */1]);
}

function spawn(node, f, args) {
  return ReActor_Scheduler.spawn(f, args, ReActor_Scheduler.leastBusy(node[/* schedulers */1]));
}

function exit(node, pid) {
  return ReActor_Scheduler.exit(pid, ReActor_Scheduler.findById(ReActor_Scheduler.pidToSid(pid))(node[/* schedulers */1]));
}

function register(node, name, pid) {
  node[/* registry */2][0] = /* :: */[
    /* tuple */[
      name,
      pid
    ],
    node[/* registry */2][0]
  ];
  return pid;
}

function where_is(node, name) {
  var byName = function (param) {
    return List.find((function (param) {
                  return name === param[0];
                }), param);
  };
  var exit = 0;
  var val;
  try {
    val = byName(node[/* registry */2][0]);
    exit = 1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return undefined;
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    return val[1];
  }
  
}

function send(node, pid, message) {
  return ReActor_Scheduler.send(pid, message, ReActor_Scheduler.findById(ReActor_Scheduler.pidToSid(pid))(node[/* schedulers */1]));
}

exports.make = make;
exports.trace = trace;
exports.spawn = spawn;
exports.exit = exit;
exports.register = register;
exports.where_is = where_is;
exports.send = send;
/* FFI_Runtime Not a pure module */
