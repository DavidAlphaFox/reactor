{0:top ðŸš€ re:actor â€” Bringing Typesafe Message-passing Concurrency to the Web}

[re:actor] is an {e experimental} type-safe, message-passing concurrency
library. It is not meant for production and has no stable API.

For the top-level library module see {!ReActor}.

{%html:
<nav class="toc">
%}
{ol
  {li {{:#introduction} Introduction}}
  {li {{:#overview} Overview}
    {ol
      {li {{:#2.1-basics} Basics}}
      {li {{:#2.2-processes-and-behaviors} Processes and Behaviors}}
      {li {{:#2.3-guaranteed-message-passing} Guaranteed Message-passing}}
      {li {{:#2.4-typesafe-message-passing} Typesafe Message-passing}}
      {li {{:#2.5-seamless-multi-core} Seamless Multi-core}}
      {li {{:#2.6-fair-scheduling} Fair Scheduling}}
      }}
  {li {{:#experiments} Experiments}
    {ol
      {li {{:#3.1-simple-spawning} Simple Spawning}}
      {li {{:#3.2-simple-message-passing} Simple Message Passing}}
      {li {{:#3.3-collaborating-processes} Collaborating Processes}}
      {li {{:#3.4-more-collaborating-processes} More Collaborating Processes}}
      {li {{:#3.5-processes-for-the-dom} Processes for the DOM}}
      {li {{:#3.6-processes-with-react} Processes with React}}
      {li {{:#3.7-tracing-messages} Tracing Messages }}
      {li {{:#3.8-processes-orchestrating-processes} Processes Orchestrating
      Processes}}
      }}
  {li {{:#benchmarks} Benchmarks}}
  {li {{:#conclusion} Conclusion}}
  {li {{:#references} References}}}
{%html:
</nav>
%}

{1:introduction 1. Introduction}

Web applications today run by default in a single-threaded event loop that does
not effectively leverage the many-core architectures available. This means that
in a many-core computer, where a web application could be potentially executing
many parallel actions at once, it typically executes only one.

The appearance of Web Workers changed this by allowing arbitrary Javascript
code to be executed in a separate event-loop that can communicate with the main
event loop via message passing and transferable data structures. To this day it
still is not trivial to leverage them: given they are very coarse low-level
features, any higher-level concurrency feature is left to be implemented at the
application level.

To aggravate this issue, a failure or resource-starvation in the main program
of a worker will effectively take the worker out of service.

To address these issues, [re:actor] began as an experiment for type-safe,
message-passing concurrent computation modeled after Smalltalk-72, Erlang, and
Gul Agha's Actor model.

This experiment will be evaluated based on how well it provides:

- Multi-core Support: or how seamlessly it allows an application to leverage
  parallelism in many-core computers.

- Failure Isolation: a process failure should not have an implicit impact on
  the rest of the system.

- Type-safe Message Passing: processes can be checked handle all of the messages
  they expect to handle at compile time.

By writing a number of small projects that showcase these capabilities.

{1:overview 2. Overview}

[re:actor] is designed to allow web applications to be expressed as a group of
independent processes that communicate by sending messages to each other, and
can run leveraging the entire of their host machines available computing power
seamlessly.

{%html:
<img
  title="re:actor powered architecture"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/reactor/docs/assets/high-level-sketch.png"
/>
%}

{2 2.1 Basics}

Let us start by introducing the basic constructs the library builds upon.

{b Processes} applications built with [re:actor] consist of running processes.
These processes model {i tasks} that have to be carried out and {i entities}
that evolve over time, in the form of {i functions} with associated identities
and mailboxes. These processes can be as simple as incrementing a counter, or
as complex as coordinating transactions across other processes. They collaborate
by {i message-passing}. In practice, processes can blend completely into the
domain of the application, making them an incredibly versatile abstraction to
model systems with.

{b Messages} Messages are typed data structures that processes send to each
other to communicate.

{b Schedulers} All processes must be scheduled for execution, and to do this
there exist schedulers. Processes and their mailboxes live within particular
schedulers. A scheduler corresponds to a single event-loop, and this could be
either the Main Thread of a browser, or a Web Worker. Every time a process send
a message, it is a scheduler that will make sure it gets delivered.

{b Nodes} All schedulers within a running system have to be orchestrated by a
node. Nodes typically map 1-to-1 with a single computer. If you're running a
[re:actor] application in a single browser, you'd normally run a single node. A
node will make sure there are as many schedulers as machine cores available and
that they are healthy at all points.
{%html:
<img
  title="Overall constructs"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/reactor/docs/assets/constructs-sketch.png"
/>
%}

{2 2.2 Processes and Behaviors}

A Process is in essence a function with an associated identity and a mailbox.

{[
type process = ( func, pid, mailbox );
]}

Every process has a unique identifier, it's {i pid}, that can be used to locate
the process and send messages to it's mailbox from anywhere in the node.

The function that defines the process is a function from a particular initial
state to a behavior change. There is a limited number of behaviors that encode
termination of a process' execution, continuation, and suspension. Additionally,
a particular mode of suspension catered for performing drawing on the Web is
included: suspension until the next animation frame. 

{[
type behavior('s) =
  | Become('s)
  | OnAnimationFrame('s)
  | Suspend(int, 's)
  | Terminate;
]}

Every process definition function will take an initial state and return one of
the above behaviors, making it possible to re-schedule itself by {i becoming} a
process with the same identity, the same definition function, and a new initial
state.

{2 2.3 Guaranteed Message-passing}

Processes communicate with other processes via {i message passing}, where a
message gets copied from the sending process to the receiving process' mailbox.

Message passing in [re:actor] is {i guaranteed to deliver messages}. However,
because the behavior of a process consists of application code that might never
consume messages from it's mailbox, it is impossible to guarantee that messages
will be consumed.

{%html:
<img
  title="Message-passing"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/reactor/docs/assets/message-passing-sketch.png"
/>
%}

To guarantee message passing, the [send] function available to all processes
within a node is {i synchronous} and will fail if the message could not be
effectively copied to the receiving mailbox.

{2 2.4 Typesafe Message-passing}

To provide further safety, a process must define exactly what messages to accept
when consuming it's mailbox, and should only be able to handle such messages.

This particular capability is powered by the type-system underneath Reason.

{2 2.5 Seamless Multi-core}

By making processes {i relocatable}, they can be started in any of the available
schedulers.

{2 2.6 Fair Scheduling}

Languages like Erlang or Smalltalk have mechanisms for principledly preemptive
scheduling, in which the execution of a particular process will be suspended,
allowing other processes to be executed without any loss of state.

However, the Web platform and in particular Javascript, have no such mechanisms.

In Javascript, any function that includes an infinite loop will yield a process
that never terminates, and any function making use of recursion may cause a
stack-overflow that will crash a process.

Because of this impediments, the scheduling of [re:actor] is designed to entrust
to the user the responsibility of building processes out of {i total functions}
that terminate in {i negligible amounts of time}. Naturally, this isn't always
possible, and when it isn't, the tradeoffs have to be made clear.

If a process' function definition is {i partial} or executes a time-intense
computation, it will block the scheduler until it terminates. 

{1:experiments 3. Experiments}

The experiments below (up to number 7th) started off as {i Koans} for the
library. They serve as good examples of how to use the library, increasing in
complexity, and to describe additional features that were found necessary to
build web applications.

{2 3.1 Simple Spawning}

{{:https://github.com/ostera/reactor/docs/blob/master/examples/koans/E1_SimpleSpawning.re}
View Source} â€” {{:/reactor/examples/koans/E1_SimpleSpawning.re.html} Run experiment (make sure to have the console open)}.

Let us begin with a simple process: a monotonically incremental counter.

{[
/**
  Sample state that includes a simple integer counter.
  */
type sample = {n: int};

/**
  A counter process that will increment it's counter by one on each evaluation.
  */
let counter: Process.f(sample) = (_env, state) => Become({n: state.n + 1});
]}

This process definition is amongst the simplest possible ones. It defines a
process that will simply become itself with a new initial state, where the
counter value [n] is incremented by 1 in every step.

{%html:
<img
  title="Process becoming a new process with new state"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/reactor/docs/assets/process-becoming.png"
/>
%}

How fast will this particular counter increment itself? As fast as it gets
scheduled for execution.

We can schedule this process for execution like this:

{[
let counter_pid: Pid.t = spawn(counter, {n: 0});
]}

But this isn't very useful, since we can't make use of that internal value
without recurring to mutable shared state with [refs]. We avoid communicating by
sharing information and instead we share information by communicating.

Let's instead add another process definition that will show us this data in some
form so we verify it is indeed working:

{[
/**
  A counter process that will increment it's counter by one on each evaluation
  and will log out a message when the counter reaches a certain number.
  */
let printing_counter: int => Process.f(sample) = (number, _env, state) => {
  if (state.n == number) {
    Js.log({j|Reached number $number|j});
  };
  Become({n: state.n + 1});
};
]}

Now spaining one process with behavior [printing_counter(2112)] will eventually
print out {i "Reached number 2112"}. A small problem appears when we have
multiple processes running in this way:

{[
let p1 = spawn(printing_counter(2112), {n: 0});
let p2 = spawn(printing_counter(2112), {n: 0});
let p3 = spawn(printing_counter(2112), {n: 0});

/* eventually... */
< Reached number 2112
< Reached number 2112
< Reached number 2112
]}

What printing belongs to which process? We can find out information about
the current process by accessing the {i process environment}: {!
ReActor_Process.env}. It is available as the [_env] parameter that we see in
both definitions above. We can use the function {! ReActor_Process.env.self} to
get the current process identifier, and refactor to print it out:

{[
let printing_counter: int => Process.f(sample) = (number, env, state) => {
  if (state.n == number) {
    let pid = env.self() |> Pid.toString;
    Js.log({j|$pid :: Reached number $number|j});
  };
  Become({n: state.n + 1});
};
]}

And now running it prints out the identifier of the process on each line:

{[
<0,0,1> :: Reached number 2112
<0,0,3> :: Reached number 2112
<0,0,2> :: Reached number 2112
]}

{%html:
<img
  title="Process becoming a new process with same identifier"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/reactor/docs/assets/process-becoming-with-identity.png"
/>
%}

{2 3.2 Simple Message Passing}
{2 3.3 Collaborating Processes}
{2 3.4 More Collaborating Processes}
{2 3.5 Processes for the DOM}
{2 3.6 Processes with React}
{2 3.7 Tracing Messages }
{2 3.8 Processes Orchestrating Processes}

{1:conclusion 4. Benchmarks}

{1:conclusion 5. Conclusion}

{1:references 6. References}

- {{:https://en.wikipedia.org/wiki/Smalltalk}Smalltalk}
- {{:http://www.erlang.org/}Erlang} and {{:https://elixir-lang.org/}Elixir}
- {{:https://arxiv.org/vc/arxiv/papers/1008/1008.1459v8.pdf}Hewitt's Actor Model
  of Computation}
- {{:https://mitpress.mit.edu/books/actors}Gul Agha's Actors}
- {{:https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API} Web
  Workers }
- {{:http://www-inst.eecs.berkeley.edu/~n252/paper/Amdahl.pdf} Amdahl's Law} 
