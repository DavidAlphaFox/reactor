{0:top ðŸš€ re:actor}

[re:actor] is an {e experimental} type-safe, message-passing concurrency
library. It is not meant for production and has no stable API.

For the top-level library module see {!ReActor}.

{%html:
<nav class="toc">
%}
{ol
  {li {{:#introduction} Introduction}}
  {li {{:#overview} Overview}
    {ol
      {li {{:#2.1-basics} Basics}}
      {li {{:#2.2-processes-and-behaviors} Processes and Behaviors}}
      {li {{:#2.3-guaranteed-message-passing} Guaranteed Message-passing}}
      {li {{:#2.4-typesafe-message-passing} Typesafe Message-passing}}
      {li {{:#2.5-seamless-multi-core} Seamless Multi-core}}
      {li {{:#2.6-fair-scheduling} Fair Scheduling}}
      }}
  {li {{:#conclusion} Conclusion}}
  {li {{:#references} References}}}
{%html:
</nav>
%}

{1:introduction 1. Introduction}

Web applications today run by default in a single-threaded event loop that does
not effectively leverage the many-core architectures available. This means that
in a many-core computer, where a web application could be potentially executing
many parallel actions at once, it typically executes only one.

The appearance of Web Workers changed this by allowing arbitrary Javascript code
to be executed in a separate event-loop that can communicate with the main event
loop via message passing and transferrable data structures. To this day it still
is not trivial to leverage them: given they are very coarse low-level features,
any higher-level concurrency feature is left to be implemented at the
application level.

To aggravate this issue, a failure or resource-starvation in the main program
of a worker will effectively take the worker out of service.

To address these issues, [re:actor] began as an experiment for type-safe,
message-passing concurrent computation modeled after Smalltalk-72, Erlang, and
Gul Agha's Actor model.

This experiment will be evaluated based on how well it provides:

- Multi-core Support: or how seamlessly it allows an application to leverage
  parallelism in many-core computers.

- Failure Isolation: a process failure should not have an implicit impact on
  the rest of the system.

- Type-safe Message Passing: processes can be checked handle all of the messages
  they expect to handle at compile time.

By writing a number of small projects that showcase these capabilities.

{1:overview 2. Overview}

[re:actor] is designed to allow web applications to be expressed as a group of
independent processes that communicate by sending messages to each other, and
can run leveraging the entire of their host machines available computing power
seamlessly.

{%html:
<img
  title="re:actor powered architecture"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/reactor/assets/high-level-sketch.png"
/>
%}

{2 2.1 Basics}

Let us start by introducing the basic constructs the library builds upon.

{b Processes} applications built with [re:actor] consist of running processes.
These processes model {i tasks} that have to be carried out and {i entities}
that evolve over time, in the form of {i functions} with associated identities
and mailboxes. These processes can be as simple as incrementing a counter, or
as complex as coordinating transactions across other processes. They collaborate
by {i message-passing}. In practice, processes can blend completely into the
domain of the application, making them an incredibly versatile abstraction to
model systems with.

{b Messages} Messages are typed data structures that processes send to each
other to communicate.

{b Schedulers} All processes must be scheduled for execution, and to do this
there exist schedulers. Processes and their mailboxes live within particular
schedulers. A scheduler corresponds to a single event-loop, and this could be
either the Main Thread of a browser, or a Web Worker. Every time a process send
a message, it is a scheduler that will make sure it gets delivered.

{b Nodes} All schedulers within a running system have to be orchestrated by a
node. Nodes typically map 1-to-1 with a single computer. If you're running a
[re:actor] application in a single browser, you'd normally run a single node. A
node will make sure there are as many schedulers as machine cores available and
that they are healthy at all points.
{%html:
<img
  title="Overall constructs"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/reactor/assets/constructs-sketch.png"
/>
%}

{2 2.2 Processes and Behaviors}

A Process is in essence a function with an associated identity and a mailbox.

{[
type process = ( func, pid, mailbox );
]}

Every process has a unique identifier, it's {i pid}, that can be used to locate
the process and send messages to it's mailbox from anywhere in the node.

The function that defines the process is a function from a particular initial
state to a behavior change. There is a limited number of behaviors that encode
termination of a process' execution, continuation, and suspension. Additionally,
a particular mode of suspension catered for performing drawing on the Web is
included: suspension until the next animation frame. 

{[
type behavior('s) =
  | Become('s)
  | OnAnimationFrame('s)
  | Suspend(int, 's)
  | Terminate;
]}

Every process definition function will take an initial state and return one of
the above behaviors, making it possible to re-schedule itself by {i becoming} a
process with the same identity, the same definition function, and a new initial
state.

{2 2.3 Guaranteed Message-passing}

Processes communicate with other processes via {i message passing}, where a
message gets copied from the sending process to the receiving process' mailbox.

Message passing in [re:actor] is {i guaranteed to deliver messages}. However,
because the behavior of a process consists of application code that might never
consume messages from it's mailbox, it is impossible to guarantee that messages
will be consumed.

{%html:
<img
  title="Message-passing"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/reactor/assets/message-passing-sketch.png"
/>
%}

{2 2.4 Typesafe Message-passing}

To provide further safety, a process must define exactly what messages to accept
when consuming it's mailbox, and should only be able to handle such messages.

This particular capability is powered by the type-system underneath Reason.

{2 2.5 Seamless Multi-core}

By making processes {i relocatable}, they can be started in any of the available
schedulers.

{2 2.6 Fair Scheduling}

Languages like Erlang or Smalltalk have mechanisms for principledly preemptive
scheduling, in which the execution of a particular process will be suspended,
allowing other processes to be executed without any loss of state.

However, the Web platform and in particular Javascript, have no such mechanisms.

In Javascript, any function that includes an infinite loop will yield a process
that never terminates, and any function making use of recursion may cause a
stack-overflow that will crash a process.

Because of this impediments, the scheduling of [re:actor] is designed to entrust
to the user the responsibility of building processes out of {i total functions}
that terminate in {i negligible amounts of time}. Naturally, this isn't always
possible, and when it isn't, the tradeoffs have to be made clear.

If a process' function definition is {i partial} or executes a time-intense
computation, it will block the scheduler until it terminates. 

{1:conclusion 3. Conclusion}

{1:references 4. References}

- {{:https://en.wikipedia.org/wiki/Smalltalk}Smalltalk}
- {{:http://www.erlang.org/}Erlang} and {{:https://elixir-lang.org/}Elixir}
- {{:https://arxiv.org/vc/arxiv/papers/1008/1008.1459v8.pdf}Hewitt's Actor Model
  of Computation}
- {{:https://mitpress.mit.edu/books/actors}Gul Agha's Actors}
- {{:https://developer.mozilla.org/en-US/reactor/Web/API/Web_Workers_API} Web
  Workers }
- {{:http://www-inst.eecs.berkeley.edu/~n252/paper/Amdahl.pdf} Amdahl's Law} 
