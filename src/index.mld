{0:top ðŸš€ re:actor}

[re:actor] is an {e experimental} type-safe, message-passing concurrency
library. It is not meant for production and has no stable API.

{3:toc Table of Contents}

+ {{:#introduction} Introduction}
+ {{:#design-and-architecture} Design and Architecture}
+ {{:#implementation} Implementation}
+ {{:#conclusion} Conclusion}
+ {{:#references} References}

{1:introduction 1. Introduction}

Web applications today run by default in a single-threaded event loop that does
not effectively leverage the many-core architectures available. This means that
in a many-core computer, where a web application could be potentially executing
many parallel actions at once, it typically executes only one.

The appearance of Web Workers changed this by allowing arbitrary Javascript code
to be executed in a separate event-loop that can communicate with the main event
loop via message passing and transferrable data structures. To this day it still
is not trivial to leverage them: given they are very coarse low-level features,
any higher-level concurrency feature is left to be implemented at the
application level.

To aggravate this issue, a failure or resource-starvation in the main program
of a worker will effectively take the worker out of service.

To address these issues, [re:actor] began as an experiment for type-safe,
message-passing concurrent computation modeled after Smalltalk-72, Erlang, and
Gul Agha's Actor model.

This experiment will be evaluated based on how well it provides:

- Symmetric Multiprocessing: or how seamlessly it allows an application to
  leverage parallelism in many-core computers.

- Failure Isolation: a process failure should not have an implicit impact on
  the rest of the system.

- Type-safe Message Passing: processes can be checked handle all of the messages
  they expect to handle at compile time.

By writing a number of small projects that showcase these capabilities.

{1:design-and-architecture 2. Design and Architecture}

[re:actor] is designed to allow web applications to be expressed as a group of
independent processes that communicate by sending messages to each other, and
can run leveraging the entire of their host machines available computing power
seamlessly.

{%html:
<img
  title="re:actor powered architecture"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/reactor/assets/high-level-sketch.png"
/>
%}

The library includes a set of constructs at different levels of abstraction for
this purpose:

- Nodes and Schedulers at the Platform-level, and
- Processes and Mesages at the Application-level.

{3 Platform-level Abstractions}

{i Nodes} are responsible for orchestrating schedulers, and they typically map
1-to-1 with a single computer. If you're running a re:actor application in a
single browser, on a single computer, you'd normally run a single node. A
node will make sure there are as many schedulers as machine cores available
and that they are healthy at all points. They also have run-time information
about the system they are running on.

{i Schedulers} are the ones that run processes and deliver messages. Each
scheduler corresponds to a single event-loop, and this could be either the
Main Thread of a browser, or a Web Worker. Every time a process send a
message, it is a scheduler that will make sure it gets delivered.

{%html:
<img
  title="Overall constructs"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/reactor/assets/constructs-sketch.png"
/>
%}

{3 Application-level Abstractions}

{i Processes} are what applications are made of. They represent {i tasks} that
have to be carried out. In the literature they are also referred to as:

- {i Objects} in Smalltalk,
- {i Actors} in the Actor-model, or
- {i Processes} in Erlang.

They can be short lived or long lived, one-offs or self-scheduling, they can be
static or change their state over time. These tasks can be as simple as
incrementing an internal counter and logging out any message that is received,
or as complex as coordinating transactions across other processes. They are an
incredibly powerful abstraction to work with.

[re:actor] applications can consist of hundreds of thousands or even millions
of processes.

Processes communicate with other processes via {i message passing}, where a
message gets copied from the sending process to the receiving process' mailbox.

{i Messages} are data structures that processes send to each other to
communicate.

Message passing in [re:actor] is {i guaranteed to deliver messages}. However,
because the behavior of a process consists of application code that might never
consume messages from it's mailbox, it is impossible to guarantee that messages
will be consumed.

{%html:
<img
  title="Message-passing"
  style="width: 100%; margin: 0.5em 0 1em 0;"
  src="/reactor/assets/message-passing-sketch.png"
/>
%}

Furthermore, a process defines exactly what messages to accept when consuming
it's mailbox, and should only be able to handle such messages.

{1:implementation 3. Implementation}

This section describes the current implementation of the [re:actor] library and
the shortcomings the web platform imposed, split into the following orthogonal
topics:

- Process spawning,
- Fair-scheduling,
- Guaranteed Message-passing
- Typesafe Message-passing

{3:process-spawning Process Spawning}

{3:fair-scheduling Fair Scheduling}

{3:guaranteed-message-passing Guaranteed Message-passing}

{3:typesafe-message-passing Typesafe Message-passing}

{1:conclusion 4. Conclusion}

{1:references 5. References}

- {{:https://en.wikipedia.org/wiki/Smalltalk}Smalltalk}
- {{:http://www.erlang.org/}Erlang} and {{:https://elixir-lang.org/}Elixir}
- {{:https://arxiv.org/vc/arxiv/papers/1008/1008.1459v8.pdf}Hewitt's Actor Model
  of Computation}
- {{:https://mitpress.mit.edu/books/actors}Gul Agha's Actors}
- {{:https://developer.mozilla.org/en-US/reactor/Web/API/Web_Workers_API} Web
  Workers }
- {{:http://www-inst.eecs.berkeley.edu/~n252/paper/Amdahl.pdf} Amdahl's Law} 
